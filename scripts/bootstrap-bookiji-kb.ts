import fs from "node:fs";
import path from "node:path";
import crypto from "node:crypto";
import matter from "gray-matter";
import { createClient } from "@supabase/supabase-js";

type Section = "faq" | "vendor" | "policy" | "troubleshooting";
type Locale = "en" | "fr";

const ROOT = path.resolve(process.cwd(), "docs", "bookiji-kb");

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  console.error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

function* walk(dir: string): Generator<string> {
  const items = fs.readdirSync(dir, { withFileTypes: true });
  for (const it of items) {
    const p = path.join(dir, it.name);
    if (it.isDirectory()) yield* walk(p);
    else if (/\.(md|mdx)$/i.test(it.name)) yield p;
  }
}

function sha256(s: string): string {
  return crypto.createHash("sha256").update(s, "utf8").digest("hex");
}

function safeLocale(x: any): Locale {
  return x === "fr" ? "fr" : "en";
}

function safeSection(x: any): Section {
  return ["faq","vendor","policy","troubleshooting"].includes(x) ? x : "faq";
}

async function upsertArticle(
  title: string,
  content: string,
  locale: Locale,
  section: Section,
  checksum: string,
  sourceRef?: string
) {
  // Check if article exists with same locale and title
  const { data: existing, error: findErr } = await supabase
    .from("kb_articles")
    .select("id, title, content, locale, section, updated_at, url")
    .eq("locale", locale)
    .ilike("title", title)
    .maybeSingle();

  if (findErr && findErr.code !== "PGRST116") throw findErr;

  if (!existing) {
    const { data, error } = await supabase
      .from("kb_articles")
      .insert({
        title,
        content,
        locale,
        section,
        url: sourceRef ?? null,
      })
      .select("id")
      .single();
    if (error) throw error;
    return { action: "inserted" as const, id: data!.id };
  } else {
    const existingChecksum = sha256(existing.content ?? "");
    if (existingChecksum === checksum) {
      return { action: "skipped" as const, id: existing.id };
    }
    const { data, error } = await supabase
      .from("kb_articles")
      .update({
        content,
        section,
        url: sourceRef ?? existing.url ?? null,
        updated_at: new Date().toISOString(),
      })
      .eq("id", existing.id)
      .select("id")
      .single();
    if (error) throw error;
    return { action: "updated" as const, id: data!.id };
  }
}

async function main() {
  if (!fs.existsSync(ROOT)) {
    console.error(`Docs folder not found: ${ROOT}`);
    process.exit(1);
  }

  let inserted = 0, updated = 0, skipped = 0, errors = 0;
  const files = Array.from(walk(ROOT));
  if (files.length === 0) {
    console.log("No Markdown files found. Put .md/.mdx files under docs/bookiji-kb/");
    return;
  }

  console.log(`Discovered ${files.length} files. Importingâ€¦\n`);
  for (const file of files) {
    try {
      const raw = fs.readFileSync(file, "utf8");
      const { data, content } = matter(raw);
      const title = (data.title || path.basename(file, path.extname(file))).toString().trim();
      const locale = safeLocale(data.locale);
      const section = safeSection(data.section);
      const sourceRef = `file://${path.relative(process.cwd(), file)}`;
      const checksum = sha256(content);

      const res = await upsertArticle(title, content, locale, section, checksum, sourceRef);
      if (res.action === "inserted") inserted++;
      else if (res.action === "updated") updated++;
      else skipped++;

      console.log(`${res.action.toUpperCase()}: [${locale}/${section}] ${title}`);
    } catch (e: any) {
      errors++;
      console.error(`ERROR on ${file}:`, e.message || e);
    }
  }

  console.log("\nDone.");
  console.table({ inserted, updated, skipped, errors });
  console.log("Embeddings will be (re)generated by the `kb_article_changed` trigger.");
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
